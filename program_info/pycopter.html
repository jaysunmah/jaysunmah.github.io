<!DOCTYPE html>
<html lang="en">
	<head>
		<meta http-equiv="content-type" content="text/html; charset=UTF-8">
		<meta charset="utf-8">
		<title>Pycopter</title>
		<meta name="generator" content="Bootply" />
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
		<link href="css/bootstrap.min.css" rel="stylesheet">
		<!--[if lt IE 9]>
			<script src="//html5shim.googlecode.com/svn/trunk/html5.js"></script>
		<![endif]-->
		<link href="css/styles.css" rel="stylesheet">
	</head>
	<body>

<header class="navbar navbar-default navbar-static-top" role="banner">
  <div class="container">
    <div class="navbar-header">
      <button class="navbar-toggle" type="button" data-toggle="collapse" data-target=".navbar-collapse">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a href="../index.html" class="navbar-brand">Jason.Ma</a>
    </div>
    <nav class="collapse navbar-collapse" role="navigation">
      <ul class="nav navbar-nav">
<!--         <li>
          <a href="#">Jason Ma</a>
        </li>
        <li>
          <a href="#">Ajay Benno</a>
        </li> -->
       
      </ul>
    </nav>
  </div>
</header>

<!-- Begin Body -->
<div class="container">
	<div class="row">
  			<div class="col-md-3" id="leftCol">
              	
				<div class="well"> 
              	<ul class="nav nav-stacked" id="sidebar">
                  <li><a href="#abstract">Abstract</a></li>
                  <li><a href="#hardware">Hardware and Wiring</a></li>
                  <li><a href="#software">Software</a></li>
                  <li><a href="#sec4">Demo</a></li>
              	</ul>
  				</div>

      		</div>  
      		<div class="col-md-9">
              	<h2 id="sec0">Pycopter</h2>
                Raspberry Pi controlled quadcopter.
           
              	<hr class="col-md-12">
              	A study of embedded systems, feedback control, and basic principles of electrical engineering. 
              	
              	<h2 id="abstract">Abstract</h2>
              	<p>
                The overall quadcopter is controlled by Hobby King's KK2.1.5 flight controller, which is responsible for the quadcopter's horizontal stabilization. The raspberry pi acts as the quadcopter's receiver, sending PWM (pulse width modulation) signals to the KK2 board, which then takes the signals in and performs the basic movements (pitch, roll, and yaw). The raspberry pi communicates with a laptop via python sockets, which allows for the user to wirelessly control the quadcopter. 
              	</p>
              	<div class="row">
                  <div class="col-md-6">
                    <div class="panel panel-default">
                      <div class="panel-heading"><h3>Big Ideas</h3></div>
                      <div class="panel-body">
                        <ul>
                          <li> <a href="#embedded">Embedded Systems</a> </li>
                          <li> <a href="#threading">Multi Threading</a> </li>
                          <li> <a href="#server">Server Client Interaction</a> </li>
                          <li> <a href="#panda">3D Engine</a> </li>
                        </ul>
                      </div>
                    </div>
                  </div>
                  <div class="col-md-6">
                      <div class="panel panel-default">
                      <div class="panel-heading"><h3>Competitive Analysis</h3></div>
                      <div class="panel-body">
                        <p>hi</p>
                      </div>
                    </div>
                  </div>  
              	</div>
              
              	<hr>
              
              	<h2 id="hardware">Hardware and Wiring</h2>
                <ul>
                <h4>List of Materials used:</h4>
                  <li>Raspberry Pi v2.0 b+ </li>
                  <li>Laptop</li>
                  <li>Hobby King 2.1.5 Flight Control Board</li>
                  <li>Glass Frame Quadcopter Kit</li>
                  <li>Turnigy 3S 2650 mAh 25C</li>
                  <li>4 x 25c ESC's</li>
                  <li>4 x Some random motors</li>
                  <li>HCSRO4 (ultrasonic sensor)</li>
                  <li>MPU6050</li>
                  <li>Wifi Dongle</li>
                  <li>Perf Board</li>
                  <li>Canakit</li>
                  <li>Power Distrubution Board (not needed, quadcopter frame  has built in power distribution board)</li>
                  <li>Jumper cables and strip wires</li>
              </ul>
                <br> </br>

              	<p>
                The list was only a simplified list of the materials I actually used. Miscellanious tools (soldering iron, screw drivers, heat shrink, etc) were also used. 
              	</p>
              	<div class="row">
              		<div class="col-md-4"><img src="//placehold.it/300x300" class="img-responsive"></div>
                  	<div class="col-md-4"><img src="//placehold.it/300x300" class="img-responsive"></div>
                  	<div class="col-md-4"><img src="//placehold.it/300x300" class="img-responsive"></div>
              	</div>
              
              	<hr>
              
              	<h2 id="software">Software</h2>

                <h4 id = "embedded">Embedded Systems</h4>
                <p> Raspberry Pi's GPIO pin library</p>
                <div style="height:400px;width:100%;border:1px solid #ccc;overflow:auto;">
                  <pre>
#uses the RPi.GPIO pin library
#more information on the library can be found here:
#https://pypi.python.org/pypi/RPi.GPIO
import RPi.GPIO as GPIO 
import time


#uses the Raspberry Pi's pin#8 (physical numbering)
LED = 8

GPIO.setmode(GPIO.BOARD)

GPIO.setup(LED, GPIO.OUT)

#configures the LED to be read as a PWM signal
led = GPIO.PWM(LED, 100)
led.start(1)

time.sleep(0.1)


pwm = 0
increasing= True

#continous loop that will raise and lower the PWM
#duty cycle (between 0% to 100%)
while True:
  while pwm < 100:
    led.ChangeDutyCycle(pwm)
    pwm += 1
    time.sleep(0.05)
  
  while pwm > 0:
    led.ChangeDutyCycle(pwm)
    pwm -= 1
    time.sleep(0.05)
                  </pre>
                </div>
                
                <br></br>

                <h4 id = "server">Server Client Interaction</h4>
                  <p> Server:</p>
                  <div style="height:400px;width:100%;border:1px solid #ccc;overflow:auto;">
                  <pre>
import socket
from _thread import *
from queue import Queue
import datetime
import tkinter
import RPi.GPIO as GPIO
import time
from mpu import compileData

####################################
# server setup (sets up the server variables)
####################################

print("type in IP address:")
HOST = input()
print("Running server on", HOST)

PORT = 21127
BACKLOG = 2

server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind((HOST, PORT))
server.listen(BACKLOG)#number of ppl that the server waits for before it starts
print("looking for connection")

clientList = []

####################################
# Motor Setup
####################################


#these terms refer to certain pin outputs on the raspberry pi
#the pins are hooked up to certain sensors which relay information
#to the pi

AIL = 15 #BCM: 22
ELE = 16 #BCM: 23
THR = 18 #BCM: 24 
RUD = 22 #BCM: 25
AUX = 24

GPIO.setmode(GPIO.BOARD)
GPIO.setup(AIL, GPIO.OUT)
GPIO.setup(ELE, GPIO.OUT)
GPIO.setup(THR, GPIO.OUT)
GPIO.setup(RUD, GPIO.OUT)
GPIO.setup(AUX, GPIO.OUT)

ail = GPIO.PWM(AIL,100)
ail.start(1)

ele = GPIO.PWM(ELE,100)
ele.start(1)

thr = GPIO.PWM(THR,100)
thr.start(1)

rud = GPIO.PWM(RUD,100)
rud.start(1)

aux = GPIO.PWM(AUX,100)
aux.start(1)

time.sleep(0.1)

#These are magic numbers that I managed to find after alot of data testing
#these are the resting values where the motors won't run. 

ailPWM = 5.3  
elePWM = 5.3
thrPWM = 5.3
rudPWM = 5.3
auxPWMOn = 8
auxPWMOff = 6

maxPWM = 9.0
minPWM = 5.3
restPWM = 7.1
thrIdle = 5.1

#The motors (ail, ele, thr, rud) function on something called
#analog data, which basically means it can take in several variations
#of power, contrary to digital data which is only 0 or 1

ail.ChangeFrequency(50)
ele.ChangeFrequency(50)
thr.ChangeFrequency(50)
rud.ChangeFrequency(50)
aux.ChangeFrequency(50)

ail.ChangeDutyCycle(ailPWM)
ele.ChangeDutyCycle(elePWM)
thr.ChangeDutyCycle(thrPWM)
rud.ChangeDutyCycle(rudPWM)
aux.ChangeDutyCycle(auxPWMOn)

####################################
# Ultrasonic Sensors setup
####################################

#sets up the ultrasonic sensors

TRIG = 12 #18
ECHO = 11 #17

GPIO.setup(TRIG, GPIO.OUT)
GPIO.output(TRIG, 0)
GPIO.setup(ECHO, GPIO.IN)

#this is the initial starting position of the copter. I implement this
#because the gyroscope doesn't read the rest position as perfectly 0,0
#so this basically can account for any slight error in the gyro readings

startingGyroValues = compileData()
startingX = startingGyroValues[0]
startingY = startingGyroValues[1]
print('start', startingX, startingY)


####################################
# The real code
####################################

#constantly checks for new messages to be sent/relayed
#takes the message and adds it to the queue, which then
#gets sent to everyone connected to the server

def handleClient(client, serverChannel):
  while True:
    msg = client.recv(100).decode('UTF-8')
    computeMessage1(msg)
    computeMessage2(msg)

def computeMessage1(msg):
  global thr, thrPWM, rud, rudPWM, aux, auxPWM, ele, elePWM, maxPWM, minPWM
  if msg == 'right':
    if rudPWM <= maxPWM: rudPWM += 0.01
    rud.ChangeDutyCycle(rudPWM)
  elif msg == 'left':
    if rudPWM >= minPWM: rudPWM -= 0.01
    rud.ChangeDutyCycle(rudPWM)
  elif msg == 'up':
    if thrPWM <= maxPWM: thrPWM += 0.01
    thr.ChangeDutyCycle(thrPWM)
  elif msg == 'down':
    if thrPWM >= minPWM: thrPWM -= 0.01
    thr.ChangeDutyCycle(5.3)
  elif msg == 'w': #forward
    if elePWM <= maxPWM: elePWM += 0.01
    ele.ChangeDutyCycle(elePWM)

def computeMessage2(msg):
  global ail, ailPWM, ele, elePWM, aux, auxPWM, maxPWM, minPWM
  if msg == 's': #backward
    if elePWM >= minPWM: elePWM -= 0.01
    ele.ChangeDutyCycle(elePWM)
  elif msg == "d": #right
    if ailPWM <= maxPWM: ailPWM += 0.01
    ail.ChangeDutyCycle(ailPWM)
  elif msg == "a": #left
    if ailPWM >= minPWM: ailPWM -= 0.01
    ail.ChangeDutyCycle(ailPWM)
  elif msg == "1":
    armCopter()
  elif msg == "2":
    disArmCopter()
  elif msg == "3": aux.ChangeDutyCycle(6)
  elif msg =="4": aux.ChangeDutyCycle(8)


#the quadcopter has a "safe" setting, like the safety on a gun
#when initially turned on, the copter will be on safe mode
#doing this process will arm the copter

def armCopter():
  serverChannel.put('arming copter...')
  rudPWM = restPWM
  rud.ChangeDutyCycle(rudPWM)
  thrPWM = thrIdle
  thr.ChangeDutyCycle(thrPWM)
  time.sleep(0.1)
  while rudPWM > restPWM - 1:
    print(rudPWM)
    rudPWM -= 0.1
    rud.ChangeDutyCycle(rudPWM)
    time.sleep(0.05)
  time.sleep(2)
  while rudPWM < 7.1:
    print(rudPWM)
    rudPWM += 0.1
    rud.ChangeDutyCycle(rudPWM)
    time.sleep(0.05)
  serverChannel.put('done') 

#this disarms the copter

def disArmCopter():
  serverChannel.put('disarming copter...')
  rudPWM = restPWM
  rud.ChangeDutyCycle(rudPWM)
  thrPWM = thrIdle
  thr.ChangeDutyCycle(thrPWM)
  time.sleep(0.2)
  while rudPWM < restPWM + 1:
    print(rudPWM)
    rudPWM += 0.1
    rud.ChangeDutyCycle(rudPWM)
    time.sleep(0.05)
  time.sleep(2)
  while rudPWM > 7.1:
    print(rudPWM)
    rudPWM -= 0.1
    rud.ChangeDutyCycle(rudPWM)
    time.sleep(0.05)
  serverChannel.put('done')

#this is constantly run to check the queue for new messages, if there is, 
#it'll put() it in the queue

def serverThread(clientList, serverChannel):
  while True:
    msg = serverChannel.get(True, None)
    for client in clientList:
      client.send(bytes(msg, "UTF-8"))


serverChannel = Queue(100)

#constantly checks for new server messages
start_new_thread(serverThread, (clientList, serverChannel))


#measures the distance of the signals that the ultrasonic sensors pick up
#the 1700 is the speed in which radio waves travel; essentially this is
#converting pulse widths of the ultra sonic waves and computing
#how far the waves had to travel

def measureDistance():
  constant = 1700
  GPIO.output(TRIG, 1)
  time.sleep(0.00001)
  GPIO.output(TRIG, 0)
  while GPIO.input(ECHO) == 0:
    pass
  start = time.time()
  while GPIO.input(ECHO) == 1:
    pass
  stop = time.time()
  return ((stop - start) * constant)

#this takes three different outputs and averages them; this makes it more
#accurate

def measureAverage():
  dist1 = measureDistance()
  time.sleep(0.1)
  dist2 = measureDistance()
  time.sleep(0.1)
  dist3 = measureDistance()
  totalDistance = (dist1 + dist2 + dist3) / 3
  return totalDistance


#this is a global dictionary; this is constantly being updated and sent
#to the client. 

msg = {"distance": 0, "ail": 0, "ele": 0, "thr": 0, "rud": 0, "gyroX": 0, 
"gyroY": 0}

#sends data to the server

def sendData(serverChannel):
  global msg
  while True:
    serverChannel.put(repr(msg))  

#constantly updates distance values

def addDistance(serverChannel):
  global msg
  while True:
    msg["distance"] = measureAverage()

#constantly updates the gyroY and gyroY values

def addGyro(serverChannel):
  global msg, startingX, startingY
  while True:
    dataVals = compileData()
    # print(dataVals)
    x = float(dataVals[0])
    y = float(dataVals[1])
    msg["gyroX"] = x - startingX
    msg["gyroY"] = y - startingY

#constantly updates the receiver inputs

def addMotorVals(serverChannel):
  global msg, ailPWM, elePWM, thrPWM, rudPWM
  while True:
    msg["ail"] = ailPWM
    msg["ele"] = elePWM
    msg["thr"] = thrPWM
    msg["rud"] = rudPWM


#resets the throttle pwm to zero once the client list is zero
#this is a safety mechanism so that once the client disconnects, 
#the throttle will shut down.

def resetMotors():
  global clientList
  while True:
    if len(clientList) < 1:
      print('nobodys here')
      thrPWM = 0

#each of these threads will update the dictionary with its respective
#attributes

start_new_thread(addDistance, (serverChannel,))
start_new_thread(addGyro, (serverChannel,))
start_new_thread(addMotorVals, (serverChannel,))
start_new_thread(sendData, (serverChannel,))

#this handles the client.

while True:
  client, address = server.accept()
  clientList.append(client)
  print("connection recieved")
  start_new_thread(handleClient, (client,serverChannel)) 
                  </pre>
                </div>
                  <br></br>
                <h4 id = "threading">Multi Threading</h4>
                  <p> Multi Threading library, discuss how I handled server responses and data updates</p>
                  <br></br>

                <h4 id = "panda">3D Engine</h4>
                  <p> Panda 3D </p>
                  <br></br>

              	<h2 id="sec4">Section 4</h2>
      			Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, 
                totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae 
                dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia cor magni dolores 
                eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, 
                sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. 
                Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut
              
              
              	<hr>
              <h4><a href="http://bootply.com/100993">Edit on Bootply</a></h4>
              	<hr>
              	
              	
      		</div> 
  	</div>
</div>



	<!-- script references -->
		<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.2/jquery.min.js"></script>
		<script src="js/bootstrap.min.js"></script>
		<script src="js/scripts.js"></script>
	</body>
</html>